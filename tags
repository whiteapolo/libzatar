!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/white/projects/libzatar/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
$(LIB)	Makefile	/^$(LIB): $(OBJ) | $(LIB_DIR)$/;"	t
$(LIB_DIR)	Makefile	/^$(LIB_DIR):$/;"	t
ADDRESS	include/shared.h	/^#define ADDRESS(/;"	d
ARROW_DOWN	include/cursor.h	/^	ARROW_DOWN = 1003,$/;"	e	enum:__anon5ecaf30c0103
ARROW_LEFT	include/cursor.h	/^	ARROW_LEFT = 1000,$/;"	e	enum:__anon5ecaf30c0103
ARROW_RIGHT	include/cursor.h	/^	ARROW_RIGHT = 1001,$/;"	e	enum:__anon5ecaf30c0103
ARROW_UP	include/cursor.h	/^	ARROW_UP = 1002,$/;"	e	enum:__anon5ecaf30c0103
B1	include/cursor.h	/^#define B1 /;"	d
B2	include/cursor.h	/^#define B2 /;"	d
B3	include/cursor.h	/^#define B3 /;"	d
B4	include/cursor.h	/^#define B4 /;"	d
B5	include/cursor.h	/^#define B5 /;"	d
B6	include/cursor.h	/^#define B6 /;"	d
B7	include/cursor.h	/^#define B7 /;"	d
B8	include/cursor.h	/^#define B8 /;"	d
BEAM_BLINKING	include/cursor.h	/^	BEAM_BLINKING = 5,$/;"	e	enum:__anon5ecaf30c0203
BEAM_STEADY	include/cursor.h	/^	BEAM_STEADY = 6,$/;"	e	enum:__anon5ecaf30c0203
BLOCK_BLINKING	include/cursor.h	/^	BLOCK_BLINKING = 1,$/;"	e	enum:__anon5ecaf30c0203
BLOCK_STEADY	include/cursor.h	/^	BLOCK_STEADY = 0,$/;"	e	enum:__anon5ecaf30c0203
C0	include/cursor.h	/^#define C0 /;"	d
C1	include/cursor.h	/^#define C1 /;"	d
C2	include/cursor.h	/^#define C2 /;"	d
C3	include/cursor.h	/^#define C3 /;"	d
C4	include/cursor.h	/^#define C4 /;"	d
C5	include/cursor.h	/^#define C5 /;"	d
C6	include/cursor.h	/^#define C6 /;"	d
C7	include/cursor.h	/^#define C7 /;"	d
C8	include/cursor.h	/^#define C8 /;"	d
CC	Makefile	/^CC = cc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -pedantic -Wall -Wextra -Iinclude$/;"	m
CTRL_KEY	include/cursor.h	/^#define CTRL_KEY(/;"	d
CURSOR_H	include/cursor.h	/^#define CURSOR_H$/;"	d
CURSOR_STYLE	include/cursor.h	/^} CURSOR_STYLE;$/;"	t	typeref:enum:__anon5ecaf30c0203
DELETE	include/cursor.h	/^	DELETE = 1004,$/;"	e	enum:__anon5ecaf30c0103
DUP	include/shared.h	/^#define DUP(/;"	d
EMPTY_KEY	include/cursor.h	/^    EMPTY_KEY = 999,$/;"	e	enum:__anon5ecaf30c0103
EMPTY_STR	include/str.h	/^#define EMPTY_STR /;"	d
END	include/cursor.h	/^	END = 1006,$/;"	e	enum:__anon5ecaf30c0103
EXPECT	tests/test.h	/^#define EXPECT(/;"	d
Err	include/shared.h	/^typedef enum { Ok = 0, Err = -1, } Result;$/;"	e	enum:__anon1273a8c50103
GRAPH_H	include/graph.h	/^#define GRAPH_H$/;"	d
GREEN	tests/test.h	/^const char *GREEN = "\\033[1;32m";$/;"	v	typeref:typename:const char *
HOME	include/cursor.h	/^	HOME = 1005,$/;"	e	enum:__anon5ecaf30c0103
LIB	Makefile	/^LIB = $(LIB_DIR)\/libzatar.a$/;"	m
LIB_DIR	Makefile	/^LIB_DIR = lib$/;"	m
LLL_H	include/list.h	/^#define LLL_H$/;"	d
MAP_H	include/map.h	/^#define MAP_H$/;"	d
MAX	include/shared.h	/^#define MAX(/;"	d
MIN	include/shared.h	/^#define MIN(/;"	d
MIN3	include/shared.h	/^#define MIN3(/;"	d
MIN_PRIORITY_QUEUE_CAPACITY	include/priorityQueue.h	/^#define MIN_PRIORITY_QUEUE_CAPACITY /;"	d
MIN_STACK_CAPACITY	include/stack.h	/^#define MIN_STACK_CAPACITY /;"	d
MIN_STR_CAPACITY	include/str.h	/^#define MIN_STR_CAPACITY /;"	d
OBJ	Makefile	/^OBJ = $(patsubst src\/%.c,obj\/%.o,$(SRC))$/;"	m
Ok	include/shared.h	/^typedef enum { Ok = 0, Err = -1, } Result;$/;"	e	enum:__anon1273a8c50103
PAGE_DOWN	include/cursor.h	/^	PAGE_DOWN = 1008,$/;"	e	enum:__anon5ecaf30c0103
PAGE_UP	include/cursor.h	/^	PAGE_UP = 1007,$/;"	e	enum:__anon5ecaf30c0103
PATH_H	include/path.h	/^#define PATH_H$/;"	d
PRIORITYQUEUE_H	include/priorityQueue.h	/^#define PRIORITYQUEUE_H$/;"	d
PipeMode	include/path.h	/^typedef enum { Read = 0, Write = 1, } PipeMode;$/;"	t	typeref:enum:__anon63864edb0103
QUEUE_H	include/queue.h	/^#define QUEUE_H$/;"	d
RED	tests/test.h	/^const char *RED   = "\\033[1;31m";$/;"	v	typeref:typename:const char *
RESET	tests/test.h	/^const char *RESET = "\\033[0m";$/;"	v	typeref:typename:const char *
RUN_TEST	tests/test.h	/^#define RUN_TEST(/;"	d
Read	include/path.h	/^typedef enum { Read = 0, Write = 1, } PipeMode;$/;"	e	enum:__anon63864edb0103
Result	include/shared.h	/^typedef enum { Ok = 0, Err = -1, } Result;$/;"	t	typeref:enum:__anon1273a8c50103
SEQUENCE	src/cursor.c	/^#define SEQUENCE(/;"	d	file:
SHARED_H	include/shared.h	/^#define SHARED_H$/;"	d
SRC	Makefile	/^SRC = $(wildcard src\/*.c)$/;"	m
STACK_H	include/stack.h	/^#define STACK_H$/;"	d
STR_H	include/str.h	/^#define STR_H$/;"	d
Scanner	include/str.h	/^} Scanner;$/;"	t	typeref:struct:__anona62d71070208
TEST	tests/priorityQueueTest.h	/^TEST(newPriorityQueueTest)$/;"	f
TEST	tests/priorityQueueTest.h	/^TEST(newPriorityQueueWithCapacityTest)$/;"	f
TEST	tests/priorityQueueTest.h	/^TEST(priorityQueueClearTest)$/;"	f
TEST	tests/priorityQueueTest.h	/^TEST(priorityQueueGetSizeTest)$/;"	f
TEST	tests/priorityQueueTest.h	/^TEST(priorityQueueIsEmptyTest)$/;"	f
TEST	tests/priorityQueueTest.h	/^TEST(priorityQueuePeekTest)$/;"	f
TEST	tests/priorityQueueTest.h	/^TEST(priorityQueuePopTest)$/;"	f
TEST	tests/priorityQueueTest.h	/^TEST(priorityQueuePushTest)$/;"	f
TEST	tests/priorityQueueTest.h	/^TEST(priorityQueueShrinkToFitTest)$/;"	f
TEST	tests/priorityQueueTest.h	/^TEST(priorityQueueTest)$/;"	f
TEST	tests/queueTest.h	/^TEST(dequeueTest)$/;"	f
TEST	tests/queueTest.h	/^TEST(enqueueTest)$/;"	f
TEST	tests/queueTest.h	/^TEST(newQueueTest)$/;"	f
TEST	tests/queueTest.h	/^TEST(queueIsEmptyTest)$/;"	f
TEST	tests/queueTest.h	/^TEST(queueTest)$/;"	f
TEST	tests/stackTest.h	/^TEST(newStackTest)$/;"	f
TEST	tests/stackTest.h	/^TEST(newStackWithCapacityTest)$/;"	f
TEST	tests/stackTest.h	/^TEST(stackClearTest)$/;"	f
TEST	tests/stackTest.h	/^TEST(stackGetSizeTest)$/;"	f
TEST	tests/stackTest.h	/^TEST(stackIsEmptyTest)$/;"	f
TEST	tests/stackTest.h	/^TEST(stackPopTest)$/;"	f
TEST	tests/stackTest.h	/^TEST(stackPushTest)$/;"	f
TEST	tests/stackTest.h	/^TEST(stackShrinkToFitTest)$/;"	f
TEST	tests/stackTest.h	/^TEST(stackTest)$/;"	f
TEST	tests/stackTest.h	/^TEST(stackTopTest)$/;"	f
TEST	tests/test.h	/^#define TEST(/;"	d
TEST_H	tests/test.h	/^#define TEST_H$/;"	d
UNDERLINE_BLINKING	include/cursor.h	/^	UNDERLINE_BLINKING = 3,$/;"	e	enum:__anon5ecaf30c0203
UNDERLINE_STEADY	include/cursor.h	/^	UNDERLINE_STEADY = 4,$/;"	e	enum:__anon5ecaf30c0203
Vertex	include/graph.h	/^} Vertex;$/;"	t	typeref:struct:__anon45d93b400108
Write	include/path.h	/^typedef enum { Read = 0, Write = 1, } PipeMode;$/;"	e	enum:__anon63864edb0103
__anon1273a8c50103	include/shared.h	/^typedef enum { Ok = 0, Err = -1, } Result;$/;"	g
__anon45d93b400108	include/graph.h	/^typedef struct {$/;"	s
__anon45d93b400208	include/graph.h	/^typedef struct {$/;"	s
__anon4eea27d30108	include/queue.h	/^typedef struct {$/;"	s
__anon5ecaf30c0103	include/cursor.h	/^enum {$/;"	g
__anon5ecaf30c0203	include/cursor.h	/^typedef enum {$/;"	g
__anon63864edb0103	include/path.h	/^typedef enum { Read = 0, Write = 1, } PipeMode;$/;"	g
__anon9c0809150108	include/priorityQueue.h	/^typedef struct {$/;"	s
__anona5b66a4c0108	include/map.h	/^typedef struct {$/;"	s
__anona62d71070108	include/str.h	/^typedef struct {$/;"	s
__anona62d71070208	include/str.h	/^typedef struct {$/;"	s
__anone63751640108	include/stack.h	/^typedef struct {$/;"	s
all	Makefile	/^all: $(LIB)$/;"	t
avlFind	src/map.c	/^void *avlFind(const avlNode *root, const void *key, int (*cmpKeys)(const void *,const void *))$/;"	f	typeref:typename:void *
avlFree	src/map.c	/^void avlFree(avlNode *root, void (*freeKey)(void *), void (*freeData)(void *))$/;"	f	typeref:typename:void
avlInsert	src/map.c	/^void avlInsert(avlNode **root, void *key, void *data, int (*cmpKeys)(const void *,const void *))$/;"	f	typeref:typename:void
avlIsExists	src/map.c	/^bool avlIsExists(const avlNode *root, const void *key, int (*cmpKeys)(const void *,const void *)/;"	f	typeref:typename:bool
avlMax	src/map.c	/^int avlMax(const int a, const int b)$/;"	f	typeref:typename:int
avlNode	include/map.h	/^typedef struct avlNode {$/;"	s
avlNode	include/map.h	/^} avlNode;$/;"	t	typeref:struct:avlNode
avlOrderTraverse	src/map.c	/^void avlOrderTraverse(const avlNode *root, void (*action)(const void *key, const void *data, voi/;"	f	typeref:typename:void
avlRemove	src/map.c	/^void avlRemove(avlNode **root, const void *key, int (*cmpKeys)(const void *,const void *), void /;"	f	typeref:typename:void
avlUpdate	src/map.c	/^void avlUpdate(avlNode *root, const void *key, int (*cmpKeys)(const void *,const void *), void (/;"	f	typeref:typename:void
capacity	include/priorityQueue.h	/^	size_t capacity;$/;"	m	struct:__anon9c0809150108	typeref:typename:size_t
capacity	include/stack.h	/^	size_t capacity;$/;"	m	struct:__anone63751640108	typeref:typename:size_t
capacity	include/str.h	/^	size_t capacity;$/;"	m	struct:__anona62d71070108	typeref:typename:size_t
charToInt	src/str.c	/^int charToInt(const char c)$/;"	f	typeref:typename:int
clean	Makefile	/^clean:$/;"	t
clearLine	src/cursor.c	/^void clearLine()$/;"	f	typeref:typename:void
clearScreen	src/cursor.c	/^void clearScreen()$/;"	f	typeref:typename:void
cmp	include/priorityQueue.h	/^	int (*cmp)(const void *, const void *);$/;"	m	struct:__anon9c0809150108	typeref:typename:int (*)(const void *,const void *)
cmpInt	tests/priorityQueueTest.h	/^int cmpInt(const void *a, const void *b)$/;"	f	typeref:typename:int
cmpKeys	include/map.h	/^	int (*cmpKeys)(const void *, const void *);$/;"	m	struct:__anona5b66a4c0108	typeref:typename:int (*)(const void *,const void *)
cmpKeysType	include/map.h	/^typedef int (*cmpKeysType)(const void *, const void *);$/;"	t	typeref:typename:int (*)(const void *,const void *)
compressPath	src/path.c	/^void compressPath(char *path)$/;"	f	typeref:typename:void
cursorDown	src/cursor.c	/^void cursorDown(int n)$/;"	f	typeref:typename:void
cursorLeft	src/cursor.c	/^void cursorLeft(int n)$/;"	f	typeref:typename:void
cursorRight	src/cursor.c	/^void cursorRight(int n)$/;"	f	typeref:typename:void
cursorUp	src/cursor.c	/^void cursorUp(int n)$/;"	f	typeref:typename:void
data	include/graph.h	/^	char data;$/;"	m	struct:__anon45d93b400108	typeref:typename:char
data	include/list.h	/^	void *data;$/;"	m	struct:list	typeref:typename:void *
data	include/map.h	/^	void *data;$/;"	m	struct:avlNode	typeref:typename:void *
data	include/stack.h	/^	void **data;$/;"	m	struct:__anone63751640108	typeref:typename:void **
data	include/str.h	/^	char *data;$/;"	m	struct:__anona62d71070108	typeref:typename:char *
dequeue	src/queue.c	/^void *dequeue(queue *q)$/;"	f	typeref:typename:void *
dirTraverse	src/path.c	/^Result dirTraverse(const char *dir, bool (*action)(const char *))$/;"	f	typeref:typename:Result
disableLineWrap	src/cursor.c	/^void disableLineWrap()$/;"	f	typeref:typename:void
disableRawMode	src/cursor.c	/^Result disableRawMode()$/;"	f	typeref:typename:Result
echoFileAppend	src/path.c	/^Result echoFileAppend(const char *fileName, const char *fmt, ...)$/;"	f	typeref:typename:Result
echoFileWrite	src/path.c	/^Result echoFileWrite(const char *fileName, const char *fmt, ...)$/;"	f	typeref:typename:Result
edges	include/graph.h	/^	bool **edges;$/;"	m	struct:__anon45d93b400208	typeref:typename:bool **
enableFullBuffering	src/cursor.c	/^Result enableFullBuffering(FILE *fp)$/;"	f	typeref:typename:Result
enableLineWrap	src/cursor.c	/^void enableLineWrap()$/;"	f	typeref:typename:void
enableRawMode	src/cursor.c	/^Result enableRawMode(int vminKeys, int vtime)$/;"	f	typeref:typename:Result
end	include/queue.h	/^    list *end;$/;"	m	struct:__anon4eea27d30108	typeref:typename:list *
enqueue	src/queue.c	/^void enqueue(queue *q, void *data)$/;"	f	typeref:typename:void
enterAlternativeScreen	src/cursor.c	/^void enterAlternativeScreen()$/;"	f	typeref:typename:void
errMessage	tests/test.h	/^const char *errMessage;$/;"	v	typeref:typename:const char *
exitAlternativeScreen	src/cursor.c	/^void exitAlternativeScreen()$/;"	f	typeref:typename:void
expandPath	src/path.c	/^void expandPath(char *path, const int maxLen)$/;"	f	typeref:typename:void
findAvlNode	src/map.c	/^const avlNode *findAvlNode(const avlNode *root, const void *key, int (*cmpKeys)(const void *,con/;"	f	typeref:typename:const avlNode *
fp	include/str.h	/^	FILE *fp;$/;"	m	struct:__anona62d71070208	typeref:typename:FILE *
getBalanceFactor	src/map.c	/^int getBalanceFactor(const avlNode *node)$/;"	f	typeref:typename:int
getCursorPos	src/cursor.c	/^Result getCursorPos(int *x, int *y)$/;"	f	typeref:typename:Result
getEditDistance	src/str.c	/^unsigned int getEditDistance(const strSlice s1, const strSlice s2)$/;"	f	typeref:typename:unsigned int
getEditDistanceC	src/str.c	/^unsigned int getEditDistanceC(const char *s1, const char *s2)$/;"	f	typeref:typename:unsigned int
getFileSize	src/shared.c	/^size_t getFileSize(FILE *fp)$/;"	f	typeref:typename:size_t
getFmtSize	src/shared.c	/^int getFmtSize(const char *fmt, ...)$/;"	f	typeref:typename:int
getFmtSizeVa	src/shared.c	/^int getFmtSizeVa(const char *fmt, va_list ap)$/;"	f	typeref:typename:int
getFullFileName	src/path.c	/^void getFullFileName(const char *dirName, const char *fileName, char *dest, int destLen)$/;"	f	typeref:typename:void
getHeight	src/map.c	/^int getHeight(const avlNode *node)$/;"	f	typeref:typename:int
getHomePath	src/path.c	/^const char *getHomePath()$/;"	f	typeref:typename:const char *
getMaxNode	src/map.c	/^avlNode *getMaxNode(avlNode *root)$/;"	f	typeref:typename:avlNode *
getMinNode	src/map.c	/^avlNode *getMinNode(avlNode *root)$/;"	f	typeref:typename:avlNode *
getPathExtention	src/path.c	/^const char *getPathExtention(const char *path)$/;"	f	typeref:typename:const char *
getScreenSize	src/cursor.c	/^Result getScreenSize(int *width, int *height)$/;"	f	typeref:typename:Result
getScreenSizeByCursor	src/cursor.c	/^Result getScreenSizeByCursor(int *width, int *height)$/;"	f	typeref:typename:Result
getScreenSizeByIoctl	src/cursor.c	/^Result getScreenSizeByIoctl(int *width, int *height)$/;"	f	typeref:typename:Result
graph	include/graph.h	/^} graph;$/;"	t	typeref:struct:__anon45d93b400208
graphAddDoubleEdge	src/graph.c	/^void graphAddDoubleEdge(graph *g, int id1, int id2)$/;"	f	typeref:typename:void
graphAddEdge	src/graph.c	/^void graphAddEdge(graph *g, int id1, int id2)$/;"	f	typeref:typename:void
graphAddVertex	src/graph.c	/^int graphAddVertex(graph *g, char data)$/;"	f	typeref:typename:int
graphForEveryAdjacent	src/graph.c	/^void graphForEveryAdjacent(graph *g, int id, void (*action)(int))$/;"	f	typeref:typename:void
graphFree	src/graph.c	/^void graphFree(graph *g)$/;"	f	typeref:typename:void
graphGetAdjacentN	src/graph.c	/^int graphGetAdjacentN(const graph *g, int id, int n)$/;"	f	typeref:typename:int
graphGetData	src/graph.c	/^char graphGetData(const graph *g, int id)$/;"	f	typeref:typename:char
graphInit	src/graph.c	/^void graphInit(graph *g)$/;"	f	typeref:typename:void
graphIsAdjacent	src/graph.c	/^bool graphIsAdjacent(const graph *g, int id1, int id2)$/;"	f	typeref:typename:bool
graphPrint	src/graph.c	/^void graphPrint(const graph *g)$/;"	f	typeref:typename:void
graphRemoveDoubleEdge	src/graph.c	/^void graphRemoveDoubleEdge(graph *g, int id1, int id2)$/;"	f	typeref:typename:void
graphRemoveEdge	src/graph.c	/^void graphRemoveEdge(graph *g, int id1, int id2)$/;"	f	typeref:typename:void
heap	include/priorityQueue.h	/^} heap;$/;"	t	typeref:struct:__anon9c0809150108
heapClear	src/priorityQueue.c	/^void heapClear(heap *h, void (*freeData)(void *))$/;"	f	typeref:typename:void
heapFree	src/priorityQueue.c	/^void heapFree(heap *h, void (*freeData)(void *))$/;"	f	typeref:typename:void
heapGetSize	src/priorityQueue.c	/^size_t heapGetSize(const heap *h)$/;"	f	typeref:typename:size_t
heapIsEmpty	src/priorityQueue.c	/^bool heapIsEmpty(const heap *h)$/;"	f	typeref:typename:bool
heapPeek	src/priorityQueue.c	/^const void *heapPeek(const heap *h)$/;"	f	typeref:typename:const void *
heapPop	src/priorityQueue.c	/^void *heapPop(heap *h)$/;"	f	typeref:typename:void *
heapPush	src/priorityQueue.c	/^void heapPush(heap *h, void *data)$/;"	f	typeref:typename:void
heapShrinkToFit	src/priorityQueue.c	/^void heapShrinkToFit(heap *h)$/;"	f	typeref:typename:void
heapifyDown	src/priorityQueue.c	/^void heapifyDown(heap *h, size_t i)$/;"	f	typeref:typename:void
heapifyUp	src/priorityQueue.c	/^void heapifyUp(heap *h, size_t i)$/;"	f	typeref:typename:void
height	include/map.h	/^	int height;$/;"	m	struct:avlNode	typeref:typename:int
hideCursor	src/cursor.c	/^void hideCursor()$/;"	f	typeref:typename:void
id	include/graph.h	/^	int id;$/;"	m	struct:__anon45d93b400108	typeref:typename:int
idCounter	src/graph.c	/^static int idCounter = 0;$/;"	v	typeref:typename:int	file:
isDir	src/path.c	/^bool isDir(const char *path)$/;"	f	typeref:typename:bool
isExtentionEqual	src/path.c	/^bool isExtentionEqual(const char *path, const char *extention)$/;"	f	typeref:typename:bool
isPathExists	src/path.c	/^bool isPathExists(const char *path)$/;"	f	typeref:typename:bool
isRegularFile	src/path.c	/^bool isRegularFile(const char *path)$/;"	f	typeref:typename:bool
key	include/map.h	/^	void *key;$/;"	m	struct:avlNode	typeref:typename:void *
left	include/map.h	/^	struct avlNode *left;$/;"	m	struct:avlNode	typeref:struct:avlNode *
left	src/priorityQueue.c	/^size_t left(size_t i)$/;"	f	typeref:typename:size_t
leftRightRotate	src/map.c	/^void leftRightRotate(avlNode **root)$/;"	f	typeref:typename:void
leftRotate	src/map.c	/^void leftRotate(avlNode **root)$/;"	f	typeref:typename:void
len	include/stack.h	/^	size_t len;$/;"	m	struct:__anone63751640108	typeref:typename:size_t
len	include/str.h	/^	size_t len;$/;"	m	struct:__anona62d71070108	typeref:typename:size_t
line	include/str.h	/^	string line;$/;"	m	struct:__anona62d71070208	typeref:typename:string
list	include/list.h	/^typedef struct list{$/;"	s
list	include/list.h	/^} list;$/;"	t	typeref:struct:list
listFree	src/list.c	/^void listFree(list **m, void (*freeData)(void *))$/;"	f	typeref:typename:void
listGetLast	src/list.c	/^const list *listGetLast(const list *l)$/;"	f	typeref:typename:const list *
listInsertAfter	src/list.c	/^void listInsertAfter(list *l, void *data)$/;"	f	typeref:typename:void
listInsertEnd	src/list.c	/^void listInsertEnd(list *l, void *data)$/;"	f	typeref:typename:void
listPop	src/list.c	/^void *listPop(list **m)$/;"	f	typeref:typename:void *
listPrint	src/list.c	/^void listPrint(const list *l, void (*printData)(void*))$/;"	f	typeref:typename:void
listPush	src/list.c	/^void listPush(list **m, void *data)$/;"	f	typeref:typename:void
listRemoveAfter	src/list.c	/^void *listRemoveAfter(list *l)$/;"	f	typeref:typename:void *
listReverse	src/list.c	/^void listReverse(list **lst)$/;"	f	typeref:typename:void
main	tests/main.c	/^int main()$/;"	f	typeref:typename:int
makeNode	src/map.c	/^avlNode *makeNode(void *key, void *data)$/;"	f	typeref:typename:avlNode *
map	include/map.h	/^} map;$/;"	t	typeref:struct:__anona5b66a4c0108
mapFind	src/map.c	/^void *mapFind(const map *m, const void *key)$/;"	f	typeref:typename:void *
mapFree	src/map.c	/^void mapFree(map *m, void (*freeKey)(void *), void (*freeData)(void *))$/;"	f	typeref:typename:void
mapInsert	src/map.c	/^void mapInsert(map *m, void *key, void *data)$/;"	f	typeref:typename:void
mapInsertAll	src/map.c	/^void mapInsertAll(map *m, ...)$/;"	f	typeref:typename:void
mapInsertAllVa	src/map.c	/^void mapInsertAllVa(map *m, va_list ap)$/;"	f	typeref:typename:void
mapIsEmpty	src/map.c	/^bool mapIsEmpty(const map *m)$/;"	f	typeref:typename:bool
mapIsExists	src/map.c	/^bool mapIsExists(const map *m, const void *key)$/;"	f	typeref:typename:bool
mapOrderTraverse	src/map.c	/^void mapOrderTraverse(const map *m, void (*action)(const void *key, const void *data, void *arg)/;"	f	typeref:typename:void
mapRemove	src/map.c	/^void mapRemove(map *m, const void *key, void (*freeKey)(void *), void (*freeData)(void *))$/;"	f	typeref:typename:void
mapUpdate	src/map.c	/^void mapUpdate(map m, const void *key, void (*freeData)(void *), void *newData)$/;"	f	typeref:typename:void
memdup	src/shared.c	/^void *memdup(const void *mem, const int size)$/;"	f	typeref:typename:void *
newHeap	src/priorityQueue.c	/^heap newHeap(int (*cmp)(const void *, const void *), const size_t initializeCapacity)$/;"	f	typeref:typename:heap
newList	src/list.c	/^list *newList()$/;"	f	typeref:typename:list *
newMap	src/map.c	/^map newMap(int (*cmpKeys)(const void *, const void *))$/;"	f	typeref:typename:map
newMapFrom	src/map.c	/^map newMapFrom(int (*cmpKeys)(const void *, const void *), void *key, void *data, ...)$/;"	f	typeref:typename:map
newPriorityQueue	src/priorityQueue.c	/^priorityQueue newPriorityQueue(int (*cmp)(const void *, const void *))$/;"	f	typeref:typename:priorityQueue
newPriorityQueueWithCapacity	src/priorityQueue.c	/^priorityQueue newPriorityQueueWithCapacity(int (*cmp)(const void *, const void *), const size_t /;"	f	typeref:typename:priorityQueue
newQueue	src/queue.c	/^queue newQueue()$/;"	f	typeref:typename:queue
newScanner	src/str.c	/^Scanner newScanner(FILE *fp)$/;"	f	typeref:typename:Scanner
newStack	src/stack.c	/^stack newStack()$/;"	f	typeref:typename:stack
newStackWithCapacity	src/stack.c	/^stack newStackWithCapacity(const size_t capacity)$/;"	f	typeref:typename:stack
newStr	src/str.c	/^string newStr(const char *fmt, ...)$/;"	f	typeref:typename:string
newStrFromArray	src/str.c	/^string newStrFromArray(char *s[], const size_t len, const char *delim)$/;"	f	typeref:typename:string
newStrFromExisting	src/str.c	/^string newStrFromExisting(const strSlice s)$/;"	f	typeref:typename:string
newStrSlice	src/str.c	/^string newStrSlice(const strSlice s, ssize_t start, ssize_t end, const ssize_t step)$/;"	f	typeref:typename:string
newStrVa	src/str.c	/^string newStrVa(const size_t minSize, const char *fmt, va_list ap)$/;"	f	typeref:typename:string
newStrWithCapacity	src/str.c	/^string newStrWithCapacity(const size_t initialCapacity, const char *fmt, ...)$/;"	f	typeref:typename:string
next	include/list.h	/^	struct list *next;$/;"	m	struct:list	typeref:struct:list *
nextInDir	src/path.c	/^Result nextInDir(DIR *dir, const char *dirName, char *destFileName, const int destLen)$/;"	f	typeref:typename:Result
obj/%.o	Makefile	/^obj\/%.o: src\/%.c | obj$/;"	t
originalTermios	src/cursor.c	/^static struct termios originalTermios;$/;"	v	typeref:struct:termios	file:
parent	src/priorityQueue.c	/^size_t parent(size_t i)$/;"	f	typeref:typename:size_t
popen2	src/path.c	/^Result popen2(char *path, char *argv[], FILE *ppipe[2])$/;"	f	typeref:typename:Result
priorityQueue	include/priorityQueue.h	/^typedef heap priorityQueue;$/;"	t	typeref:typename:heap
priorityQueueClear	src/priorityQueue.c	/^void priorityQueueClear(priorityQueue *q, void (*freeData)(void *))$/;"	f	typeref:typename:void
priorityQueueFree	src/priorityQueue.c	/^void priorityQueueFree(priorityQueue *q, void (*freeData)(void *))$/;"	f	typeref:typename:void
priorityQueueGetSize	src/priorityQueue.c	/^size_t priorityQueueGetSize(const priorityQueue *q)$/;"	f	typeref:typename:size_t
priorityQueueIsEmpty	src/priorityQueue.c	/^bool priorityQueueIsEmpty(const priorityQueue *q)$/;"	f	typeref:typename:bool
priorityQueuePeek	src/priorityQueue.c	/^const void *priorityQueuePeek(const priorityQueue *q)$/;"	f	typeref:typename:const void *
priorityQueuePop	src/priorityQueue.c	/^void *priorityQueuePop(priorityQueue *q)$/;"	f	typeref:typename:void *
priorityQueuePush	src/priorityQueue.c	/^void priorityQueuePush(priorityQueue *q, void *data)$/;"	f	typeref:typename:void
priorityQueueShrinkToFit	src/priorityQueue.c	/^void priorityQueueShrinkToFit(priorityQueue *q)$/;"	f	typeref:typename:void
queue	include/queue.h	/^} queue;$/;"	t	typeref:struct:__anon4eea27d30108
queueClear	src/queue.c	/^void queueClear(queue *q, void (*freeData)(void *))$/;"	f	typeref:typename:void
queueFree	src/queue.c	/^void queueFree(queue *q, void (*freeData)(void *))$/;"	f	typeref:typename:void
queueIsEmpty	src/queue.c	/^bool queueIsEmpty(const queue *q)$/;"	f	typeref:typename:bool
queuePrint	src/queue.c	/^void queuePrint(const queue *q, void (*printData)(void *))$/;"	f	typeref:typename:void
readEscapeKey	src/cursor.c	/^int readEscapeKey()$/;"	f	typeref:typename:int
readFile	src/path.c	/^Result readFile(const char *fileName, const char *fmt, ...)$/;"	f	typeref:typename:Result
readKey	src/cursor.c	/^int readKey()$/;"	f	typeref:typename:int
readWholeFile	src/str.c	/^string readWholeFile(const char *fileName)$/;"	f	typeref:typename:string
redirectFd	src/path.c	/^Result redirectFd(int srcFd, const char *destFileName)$/;"	f	typeref:typename:Result
registerChangeInWindowSize	src/cursor.c	/^Result registerChangeInWindowSize(void (*funciton)(int))$/;"	f	typeref:typename:Result
restoreCursorPos	src/cursor.c	/^void restoreCursorPos()$/;"	f	typeref:typename:void
right	include/map.h	/^	struct avlNode *right;$/;"	m	struct:avlNode	typeref:struct:avlNode *
right	src/priorityQueue.c	/^size_t right(size_t i)$/;"	f	typeref:typename:size_t
rightLeftRotate	src/map.c	/^void rightLeftRotate(avlNode **root)$/;"	f	typeref:typename:void
rightRotate	src/map.c	/^void rightRotate(avlNode **root)$/;"	f	typeref:typename:void
root	include/map.h	/^	avlNode *root;$/;"	m	struct:__anona5b66a4c0108	typeref:typename:avlNode *
saveCursorPos	src/cursor.c	/^void saveCursorPos()$/;"	f	typeref:typename:void
scannerFree	src/str.c	/^void scannerFree(Scanner *scanner)$/;"	f	typeref:typename:void
scannerNextLine	src/str.c	/^const string *scannerNextLine(Scanner *scanner)$/;"	f	typeref:typename:const string *
setCursorPos	src/cursor.c	/^void setCursorPos(int x, int y)$/;"	f	typeref:typename:void
setCursorStyle	src/cursor.c	/^void setCursorStyle(CURSOR_STYLE style)$/;"	f	typeref:typename:void
setCursorX	src/cursor.c	/^void setCursorX(int x)$/;"	f	typeref:typename:void
showCursor	src/cursor.c	/^void showCursor()$/;"	f	typeref:typename:void
size	include/graph.h	/^	int size;$/;"	m	struct:__anon45d93b400208	typeref:typename:int
size	include/priorityQueue.h	/^	size_t size;$/;"	m	struct:__anon9c0809150108	typeref:typename:size_t
sliceStr	src/str.c	/^strSlice sliceStr(const char *s, const size_t len)$/;"	f	typeref:typename:strSlice
sliceStrC	src/str.c	/^strSlice sliceStrC(const char *s)$/;"	f	typeref:typename:strSlice
sliceStrRange	src/str.c	/^strSlice sliceStrRange(const strSlice s, const size_t start, const size_t end)$/;"	f	typeref:typename:strSlice
stack	include/stack.h	/^} stack;$/;"	t	typeref:struct:__anone63751640108
stackClear	src/stack.c	/^void stackClear(stack *s)$/;"	f	typeref:typename:void
stackFree	src/stack.c	/^void stackFree(stack *s, void (*freeData)(void *))$/;"	f	typeref:typename:void
stackGetSize	src/stack.c	/^size_t stackGetSize(const stack *s)$/;"	f	typeref:typename:size_t
stackIsEmpty	src/stack.c	/^bool stackIsEmpty(const stack *s)$/;"	f	typeref:typename:bool
stackPop	src/stack.c	/^void *stackPop(stack *s)$/;"	f	typeref:typename:void *
stackPush	src/stack.c	/^void stackPush(stack *s, void *data)$/;"	f	typeref:typename:void
stackShrinkToFit	src/stack.c	/^void stackShrinkToFit(stack *s)$/;"	f	typeref:typename:void
stackTop	src/stack.c	/^void *stackTop(const stack *s)$/;"	f	typeref:typename:void *
start	include/queue.h	/^    list *start;$/;"	m	struct:__anon4eea27d30108	typeref:typename:list *
strChr	src/str.c	/^ssize_t strChr(const strSlice haystack, const char needle, const size_t startOffset, size_t occu/;"	f	typeref:typename:ssize_t
strClear	src/str.c	/^void strClear(string *s)$/;"	f	typeref:typename:void
strCmp	src/str.c	/^int strCmp(const strSlice s1, const strSlice s2)$/;"	f	typeref:typename:int
strCmpC	src/str.c	/^int strCmpC(const strSlice s1, const char *s2)$/;"	f	typeref:typename:int
strCountc	src/str.c	/^size_t strCountc(const strSlice haystack, const char needle)$/;"	f	typeref:typename:size_t
strCounts	src/str.c	/^size_t strCounts(const strSlice haystack, const strSlice needle)$/;"	f	typeref:typename:size_t
strCountsC	src/str.c	/^size_t strCountsC(const strSlice haystack, const char *needle)$/;"	f	typeref:typename:size_t
strCut	src/str.c	/^void strCut(string *s, const size_t start, const size_t end)$/;"	f	typeref:typename:void
strDebugPrint	src/str.c	/^void strDebugPrint(const strSlice s)$/;"	f	typeref:typename:void
strDisplayedLength	src/str.c	/^size_t strDisplayedLength(const strSlice s)$/;"	f	typeref:typename:size_t
strExtractBetween	src/str.c	/^strSlice strExtractBetween(const strSlice s, const strSlice left, const strSlice right)$/;"	f	typeref:typename:strSlice
strExtractBetweenC	src/str.c	/^strSlice strExtractBetweenC(const strSlice s, const char *left, const char *right)$/;"	f	typeref:typename:strSlice
strForEachTok	src/str.c	/^void strForEachTok(const strSlice s, const char *delim, void (*action)(const strSlice))$/;"	f	typeref:typename:void
strFree	src/str.c	/^void strFree(string *s)$/;"	f	typeref:typename:void
strGetLine	src/str.c	/^string strGetLine(FILE *fp)$/;"	f	typeref:typename:string
strInput	src/str.c	/^string strInput(const char *prompt)$/;"	f	typeref:typename:string
strIsEmpty	src/str.c	/^bool strIsEmpty(const strSlice s)$/;"	f	typeref:typename:bool
strIsEqual	src/str.c	/^bool strIsEqual(const strSlice s1, const strSlice s2)$/;"	f	typeref:typename:bool
strIsEqualC	src/str.c	/^bool strIsEqualC(const strSlice s1, const char *s2)$/;"	f	typeref:typename:bool
strIsNumeric	src/str.c	/^bool strIsNumeric(const strSlice s)$/;"	f	typeref:typename:bool
strPopc	src/str.c	/^char strPopc(string *s)$/;"	f	typeref:typename:char
strPrint	src/str.c	/^void strPrint(const strSlice s)$/;"	f	typeref:typename:void
strPrintln	src/str.c	/^void strPrintln(const strSlice s)$/;"	f	typeref:typename:void
strPush	src/str.c	/^void strPush(string *s, const strSlice src)$/;"	f	typeref:typename:void
strPushc	src/str.c	/^void strPushc(string *s, const char c)$/;"	f	typeref:typename:void
strPushcAt	src/str.c	/^void strPushcAt(string *s, const size_t n, const char c)$/;"	f	typeref:typename:void
strPushs	src/str.c	/^void strPushs(string *s, const char *fmt, ...)$/;"	f	typeref:typename:void
strPushsAt	src/str.c	/^void strPushsAt(string *s, const size_t n, const char *fmt, ...)$/;"	f	typeref:typename:void
strReplace	src/str.c	/^void strReplace(string *s, const char *sub, const char *by, size_t maxOccurrences)$/;"	f	typeref:typename:void
strReplaceAll	src/str.c	/^void strReplaceAll(string *s, const char *sub, const char *by)$/;"	f	typeref:typename:void
strReverse	src/str.c	/^void strReverse(string *s)$/;"	f	typeref:typename:void
strScanf	src/str.c	/^int strScanf(const strSlice s, const char *fmt, ...)$/;"	f	typeref:typename:int
strShrinkToFit	src/str.c	/^void strShrinkToFit(string *s)$/;"	f	typeref:typename:void
strSlice	include/str.h	/^typedef string strSlice;$/;"	t	typeref:typename:string
strStr	src/str.c	/^ssize_t strStr(const strSlice haystack, const strSlice needle, const size_t startOffset)$/;"	f	typeref:typename:ssize_t
strStrC	src/str.c	/^ssize_t strStrC(const strSlice haystack, const char *needle, const size_t startOffset)$/;"	f	typeref:typename:ssize_t
strToLower	src/str.c	/^void strToLower(string *s)$/;"	f	typeref:typename:void
strToNumeric	src/str.c	/^long long strToNumeric(const strSlice s)$/;"	f	typeref:typename:long long
strToUpper	src/str.c	/^void strToUpper(string *s)$/;"	f	typeref:typename:void
strTok	src/str.c	/^strSlice strTok(const strSlice s, const strSlice prevSlice, const char *delim)$/;"	f	typeref:typename:strSlice
strTokStart	src/str.c	/^strSlice strTokStart(const strSlice s, const char *delim)$/;"	f	typeref:typename:strSlice
strTopc	src/str.c	/^char strTopc(const strSlice s)$/;"	f	typeref:typename:char
strTrim	src/str.c	/^void strTrim(string *s)$/;"	f	typeref:typename:void
strTrimCset	src/str.c	/^void strTrimCset(string *s, const char *cset)$/;"	f	typeref:typename:void
string	include/str.h	/^} string;$/;"	t	typeref:struct:__anona62d71070108
strnCmp	src/str.c	/^int strnCmp(const strSlice s1, const strSlice s2, size_t n)$/;"	f	typeref:typename:int
strnCmpC	src/str.c	/^int strnCmpC(const strSlice s1, const char *s2, const size_t n)$/;"	f	typeref:typename:int
strnIsEqual	src/str.c	/^bool strnIsEqual(const strSlice s1, const strSlice s2, const size_t n)$/;"	f	typeref:typename:bool
strnIsEqualC	src/str.c	/^bool strnIsEqualC(const strSlice s1, const char *s2, const size_t n)$/;"	f	typeref:typename:bool
strrChr	src/str.c	/^ssize_t strrChr(const strSlice haystack, const char needle, const size_t startOffset, size_t occ/;"	f	typeref:typename:ssize_t
swap	src/shared.c	/^void swap(void *a, void *b, const size_t size)$/;"	f	typeref:typename:void
test	Makefile	/^test: $(LIB)$/;"	t
testName	tests/test.h	/^const char *testName;$/;"	v	typeref:typename:const char *
traverseFile	src/path.c	/^Result traverseFile(const char *fileName, const int bufSize, bool (*action)(char[bufSize]))$/;"	f	typeref:typename:Result
updateHeight	src/map.c	/^void updateHeight(avlNode *node)$/;"	f	typeref:typename:void
updateScreen	src/cursor.c	/^void updateScreen()$/;"	f	typeref:typename:void
vec	include/priorityQueue.h	/^	void **vec;$/;"	m	struct:__anon9c0809150108	typeref:typename:void **
vertecies	include/graph.h	/^	Vertex *vertecies;$/;"	m	struct:__anon45d93b400208	typeref:typename:Vertex *
waitForByte	src/cursor.c	/^int waitForByte()$/;"	f	typeref:typename:int
